m <- mtcars
m
m
str(m)
head(m)
x <- readClipboard()
x
x <- readClipboard()
x
x <- read.table(file = "clipboard", sep = "t")
x
x <- read.table(file = "clipboard", sep = "\t")
x
?read.table
x <- read.table("clipboard")
x
x <- read.table("clipboard", header = TRUE)
x
names(x)
mat <- as.matrix(x)
mat
library(plotly)
plotly::add_heatmap(mat)
plot_ly(mat)
plot_ly(x)
plot_ly(x, type='heatmap')
plot_ly(z=m, type='heatmap')
plot_ly(z=mat, type='heatmap')
volcano
plot_ly(z=volcano, type='heatmap')
plot_ly(z=mat, type='heatmap')
plot_ly(z=x, type='heatmap')
plot_ly(z=mat, type='heatmap')
x1 <- read.table('clipboard', headers=TRUE)
x1 <- read.table('clipboard', header=TRUE)
dim(x1)
m1 <- as.matrix(x1)
class(x1)
class(m1)
l1 <- as.list(m1)
class(l1)
head(x1)
x1[1:10,1:10]
m1[1:10,1:10]
m1 * 2
m1[1:10,1:10]
plot(m1)
heatmap(m1)
plot_ly(m1)
plot_ly(z=m1,'heatmap')
plot_ly(z=m1, type='heatmap')
?plot_ly
sqrt(0.5**2+0.5**2)
cd
getwd()
# Set the working directory
setwd('~/../Google Drive/Alteryx/Challenges/Challenges 001-010/challenge_1/')
# Load the data
ref <- load('ref.rdata')
postcodes <- load('postcodes.rdata')
r1 <- as.integer(substr(ref$Range, 1, 4))
# Load the data
load('ref.rdata')
load('postcodes.rdata')
r1 <- as.integer(substr(ref$Range, 1, 4))
r2 <- as.integer(substr(ref$Range, 6, 9))
# Create an empty list
ref.list = list()
# Each list entry contains the whole row
for (i in 1:nrow(ref)){
ref.list[[i]] <- cbind(RowCount = r1[i]:r2[i], df)
}
# Use rbindlist from the data.table package to concatenate
# the list of data frames.
# Can also use rbind.fill from the plyr package.
df <- rbindlist(df.list)
library(data.table)
# Use rbindlist from the data.table package to concatenate
# the list of data frames.
# Can also use rbind.fill from the plyr package.
df <- rbindlist(df.list)
# Use rbindlist from the data.table package to concatenate
# the list of data frames.
# Can also use rbind.fill from the plyr package.
ref <- rbindlist(ref.list)
# Create an empty list
ref.list = list()
# Each list entry contains the whole row
for (i in 1:nrow(ref)){
ref.list[[i]] <- cbind(RowCount = r1[i]:r2[i], ref)
}
# Use rbindlist from the data.table package to concatenate
# the list of data frames.
# Can also use rbind.fill from the plyr package.
ref <- rbindlist(ref.list)
# Join the data frames
postcodes <- merge(postcodes, ref,
by.x = 'Postal.Area', by.y = 'RowCount')
dim(postcodes)
names(postcodes)
head(ref)
head(postcodes)
head(postcodes)
dt <- as.data.table(postcodes)
dt
dt[,.N,by=Postal.Area]
dt[,.N,by=c(Postal.Area, Sales.Rep)]
dt[,.N,by=.(Postal.Area, Sales.Rep)]
dt[,.N,by=.(Postal.Area, Sales.Rep, Responder)]
dt[,.N,by=.(Region, Sales.Rep, Responder)]
load(postcodes)
load('post')
load('postcodes.rdata')
# Load the data
load('ref.rdata')
load('postcodes.rdata')
r1 <- as.integer(substr(ref$Range, 1, 4))
r2 <- as.integer(substr(ref$Range, 6, 9))
# Create an empty list
ref.list = list()
# Each list entry contains the whole row
for (i in 1:nrow(ref)){
ref.list[[i]] <- cbind(RowCount = r1[i]:r2[i], ref)
}
# Use rbindlist from the data.table package to concatenate
# the list of data frames.
# Can also use rbind.fill from the plyr package.
ref <- rbindlist(ref.list)
# Join the data frames
dt <- merge(postcodes, ref,
by.x = 'Postal.Area',
by.y = 'RowCount')
table(ref$RowCount)
table(postcodes$Postal.Area)
ref
nrow(ref)
# Load the data
load('ref.rdata')
ref
nrow(ref)
r1
r2
# Create an empty list
ref.list = list()
# Each list entry contains the whole row
for (i in 1:nrow(ref)){
ref.list[[i]] <- cbind(RowCount = r1[i]:r2[i], ref)
}
ref.list
# Each list entry contains the whole row
for (i in 1:nrow(ref)){
print(i)
ref.list[[i]] <- cbind(RowCount = r1[i]:r2[i], ref)
}
ref
# Create an empty list
ref.list = list()
# Each list entry contains the whole row
for (i in 1:nrow(ref)){
print(i)
ref.list[[i]] <- cbind(RowCount = r1[i]:r2[i], ref[i])
}
r1[5]
r2[5]
r1[5]:r2[5]
ref[5]
ref[,5]
ref[5,]
# Create an empty list
ref.list = list()
# Each list entry contains the whole row
for (i in 1:nrow(ref)){
print(i)
ref.list[[i]] <- cbind(RowCount = r1[i]:r2[i], ref[i,])
}
ref.list[[i]] <- cbind(RowCount = r1[i]:r2[i], ref[i,], row.names = F)
ref.list[[i]] <- cbind(RowCount = r1[i]:r2[i], ref[i,], row.names = NULL)
ref.list[[i]] <- cbind(RowCount = r1[i]:r2[i], ref[i,], row.names = .N)
# Create an empty list
ref.list = list()
# Each list entry contains the whole row
for (i in 1:nrow(ref)){
print(i)
ref.list[[i]] <- cbind(RowCount = r1[i]:r2[i], ref[i,], row.names = .N)
}
head(ref.list)
# Each list entry contains the whole row
for (i in 1:nrow(ref)){
print(i)
ref.list[[i]] <- cbind(RowCount = r1[i]:r2[i], ref[i,], row.names = RowCount)
}
# Create an empty list
ref.list = list()
# Each list entry contains the whole row
for (i in 1:nrow(ref)){
print(i)
code = r1[i]:r2[i]
ref.list[[i]] <- cbind(RowCount = code, ref[i,], row.names = code)
}
for (i in 1:5) head(ref.list[i])
head(ref.list)
# Use rbindlist from the data.table package to concatenate
# the list of data frames.
# Can also use rbind.fill from the plyr package.
ref <- rbindlist(ref.list)
ref
str(ref)
# Join the data frames
dt <- merge(postcodes, ref,
by.x = 'Postal.Area',
by.y = 'RowCount')
str(dt)
# Join the data frames
dt <- merge(ref, postcodes,
by.y = 'RowCount',
by.x = 'Postal.Area')
# Join the data frames
dt <- merge(ref, postcodes,
by.x = 'RowCount',
by.y = 'Postal.Area')
class(dt)
ref[postcodes]
# Join the data frames
dt <- merge(ref, postcodes,
by.x = 'RowCount',
by.y = 'Postal.Area',)
# Join the data frames
dt <- merge(ref, postcodes,
by.x = 'RowCount',
by.y = 'Postal.Area',)
# Join the data frames
dt <- merge(ref, postcodes,
by.x = 'RowCount',
by.y = 'Postal.Area',
all = FALSE)
dt
(dt1 <- data.table(A = letters[1:10], X = 1:10, key = "A"))
(dt2 <- data.table(A = letters[5:14], Y = 1:10, key = "A"))
merge(dt1,dt2)
merge(dt1,dt2,all = T)
# Summarise
sapply(dt, function(x) length(unique(x)))
sqr <- function(x) x**2
sqr(3)
sqr(4)
sqr(5)
sqr(1:5)
# Summarize
ans <- dt[,.(num_of_customers = length(unique(Customer.ID))), by = .(Region)]
ans
# Summarize
ans <- dt[,.(Number of Customers = length(unique(Customer.ID))), by = .(Region)]
# Summarize
ans <- dt[,.('Number of Customers'= length(unique(Customer.ID))), by = .(Region)]
ans
# Summarize
ans <- dt[,.(Count= length(unique(Customer.ID))),
by = .(Region, Sales.Rep, Responder)]
dim(ans)
ans
sapply?
?sapply
source('C:/Users/phili/Google Drive/Alteryx/Challenges/Challenges 001-010/challenge_1/challenge_1.R')
source('C:/Users/phili/Google Drive/Alteryx/Challenges/Challenges 001-010/challenge_1/challenge_1.R')
# Check number of unique values across whole data table
sapply(dt, function(x) length(unique(x)))
# Time it
ptm <- proc.time()
library(data.table)
# Set the working directory
setwd('~/../Google Drive/Alteryx/Challenges/Challenges 001-010/challenge_1/')
# Load the data
load('ref.rdata')
load('postcodes.rdata')
# Extract the postcode areas from the Range and convert to numbers
r1 <- as.integer(substr(ref$Range, 1, 4))
r2 <- as.integer(substr(ref$Range, 6, 9))
# Create an empty list
ref.list = list()
# Each list entry contains the whole range of postcode values
for (i in 1:nrow(ref)){
ref.list[[i]] <- cbind(RowCount = r1[i]:r2[i], ref[i,],
row.names = NULL)
}
# Concatenate the list of data frames into one single data frame
# 1. Using rbindlist from the data.table backage.
# 2. Or using rbind.fill from the plyr package.
ref <- rbindlist(ref.list)
# Join the data frames
# NB: put the data.table first for the merged object to be a data.table.
dt <- merge(ref, postcodes,
by.x = 'RowCount',
by.y = 'Postal.Area')
# Check number of unique values across whole data table
sapply(dt, function(x) length(unique(x)))
# Summarize
ans <- dt[,.(Count= length(unique(Customer.ID))),
by = .(Region, Sales.Rep, Responder)]
print('runtime = ' + ptm-proc.time())
ptm
ptm-proc.time()
